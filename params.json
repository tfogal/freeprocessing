{"name":"Freeprocessing","tagline":"in situ visualization tool","body":"This is a data transfer symbiont.  It is essentially 'tee' in library form.\r\n\r\nTo use it, `LD_PRELOAD` the library (`libsitu.so`) into your program.  At that\r\npoint, it looks for all of your `write` calls and does its magic.\r\n\r\nConfiguration\r\n=============\r\n\r\nThe library looks for a library named `situ.cfg`.  This library defines\r\nwhat libraries should be loaded.  The general format is basically like\r\nawk, except that instead of specifying the code to run, you specify a\r\nlibrary that implements that code:\r\n\r\n  pattern { exec: /path/to/library.so }\r\n\r\nWhere `pattern` is a shell glob and `library.so` is a library\r\nimplementing a pre-prescribed interface (see `LIBRARIES`).  An example:\r\n\r\n```\r\n  *header* { exec: ./libmine.so }\r\n  *.data { exec: ./libmine.so }\r\n  *tosend* { exec: ./libinstr.so }\r\n```\r\n\r\nThis defines three processing elements, `libmine` will be used whenever\r\na filename which matches `*header*` or `*.data` is accessed.  *Both*\r\ninstances get called.  The order they are called is undefined.\r\n\r\nSharing internal memory\r\n-----------------------\r\n\r\nIf a single library is given in multiple patterns, the matches *share*\r\nprivate variable instances.  In the above example, both `libmine.so`\r\ninstances will access a single set of shared variables.  This allows\r\nyou to (for instance) parse the program's header output and communicate\r\nsuch information to the part of the code which instruments the binary\r\noutputs.\r\n\r\nIf you actually want two instances of a library, with unique internal\r\nvariables each time, just rename one of them.  The equivalency is\r\nbased purely on the name of the libraries, so libraries of different\r\nnames---even if they are the exact sample implementation---will not\r\nshare private data.\r\n\r\nLibraries\r\n=========\r\n\r\nLibraries need only export one function:\r\n\r\n  1. `void exec(const char* fn, const void* buf, size_t n)`\r\n\r\nIt is called anytime a file is written to.  The filename given in the\r\nfirst argument is the exact filename (not, for example, the pattern\r\ngiven in the configuration file).\r\n\r\nThe symbiont attempts to take care of the issue of partial writes;\r\nthere should be a 1-1 mapping between program `write`s and `exec`\r\ninvocations.\r\n\r\nLibraries can optionally implement two additional functions:\r\n\r\n  2. `void metadata(const char* fn, const size_t dims[3], int)`, and\r\n  3. `void finish(const char* fn)`\r\n\r\n`metadata` is called directly before `exec`, in the case that the\r\nsimulation knows metadata for the impending `write`.  This is only\r\npossible with some self-describing transport mechanisms.  If your code\r\ndoes not utilize IO middleware, this function will never be called.\r\nIn this case, you have to provide any needed metadata yourself.  We\r\nrecommend parsing a config file the first time `exec` is called.\r\n\r\n`finish` notifies you when the program is finished with a file or\r\npattern.  Good time to clean up resources.\r\n\r\nEnvironment\r\n===========\r\n\r\n  * `LIBSITU_DEBUG`: used to selectively enable debug information.  See\r\n  below for more info.\r\n\r\nForking\r\n-------\r\n\r\nThere can be issues forking processes.  This includes using `system`.\r\nTherefore, the library unsets `LD_PRELOAD` during initialization, so\r\nthat it will not instrument any child processes.\r\n\r\nFor the most part, this is what you want.  However, this may cause\r\nproblems if you have a complicated loading procedure (\"mpirun\" and\r\n\"valgrind\" come to mind).  To get the code to run under MPI, you want\r\nthe `mpirun` program to set the environment variable for you, instead\r\nof setting it before `mpirun` is invoked.  OpenMPI's `mpirun`s let you\r\ndo this with `-x`, e.g.:\r\n\r\n  mpirun -x LD_PRELOAD=./libsitu.so -np 4 ./myprogram\r\n\r\nFor MPICH, this option is `-env` and the setting should lack the `=`\r\ncharacter:\r\n\r\n  mpiexec -env LD_PRELOAD ./libsitu.so -np 4 ./myprogram\r\n\r\nBlueGene's are even more unique:\r\n\r\n  runjob --envs LD_PRELOAD=./libsitu.so --exe ./myprogram\r\n\r\nDebug Channel Settings\r\n======================\r\n\r\nThe symbiont has a set of unique debug channels.  Generally these are\r\nall related to a specific feature, such as investigating when files are\r\nopened, or when data is transferred, or other information.\r\n\r\nIn addition, each channel has a set of *class*es, which might loosely\r\nbe thought of as severity.  So you can, for example, turn on only the\r\nwarnings from a particular channel, or only the errors.\r\n\r\nThe way one configures these channels is through the\r\n`LIBSITU_DEBUG` environment variable.  The general form is `channel\r\nname=[+-]class[,...]`, e.g.:\r\n\r\n  opens=+warn\r\n\r\nwhich says to enable warnings on the channel `opens`.  Multiple class\r\nspecifications are separated by commas:\r\n\r\n  opens=+trace,-warn\r\n\r\nMultiple channels are delimited by semicolons:\r\n\r\n  opens=+trace,-warn;writes=+trace\r\n\r\nThe currently defined channels are:\r\n\r\n  * `opens`: all `open`-esque calls, along with their `close`\r\n  counterparts.\r\n  * `freeproc`: loading and using libraries\r\n  * `writes`: all `write`-esque calls. (*CAUTION*: spammy)\r\n  * `posix`: trace POSIX I/O calls.\r\n  * `hdf5`: HDF5 calls of interest.\r\n\r\nThe currently defined classes are:\r\n\r\n  * `err`: errors which almost certainly indicate a bug in either the\r\n  symbiont or the host program.\r\n  * `warn`: generally anomalous conditions which might not be a\r\n  problem, such as an internal table filling up.\r\n  * `trace`: notification *when* a call occurs, in a manner similar to\r\n  `strace(1)` or `ltrace(1)`.\r\n\r\nNotes\r\n=====\r\n\r\nIt seems that the executable needs to be built as position-independent\r\ncode for this to work.\r\n\r\nif the code is not position-independent, then\r\n`__attribute__((constructor))` functions do not get run and thus our\r\nfunction pointers never get initialized.\r\n\r\nFortran may work a bit differently, doesn't seem required there.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}